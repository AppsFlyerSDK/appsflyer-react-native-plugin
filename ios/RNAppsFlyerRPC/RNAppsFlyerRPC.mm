//
//  RNAppsFlyerRPC.mm
//  react-native-appsflyer
//
//  Objective-C Implementation for RNAppsFlyerRPC TurboModule
//

#import "RNAppsFlyerRPC.h"
#import <React/RCTBridgeModule.h>
#import <React/RCTLog.h>

// Import Codegen spec only for New Architecture (if available)
#ifdef RCT_NEW_ARCH_ENABLED
#if __has_include(<ReactCodegen/ReactNativeAppsFlyerSpec/ReactNativeAppsFlyerSpec.h>)
#import <ReactCodegen/ReactNativeAppsFlyerSpec/ReactNativeAppsFlyerSpec.h>
#elif __has_include(<ReactNativeAppsFlyerSpec/ReactNativeAppsFlyerSpec.h>)
#import <ReactNativeAppsFlyerSpec/ReactNativeAppsFlyerSpec.h>
#endif
#endif // RCT_NEW_ARCH_ENABLED

// Import Swift header to access Swift implementation class
// The Swift header is auto-generated by Xcode when Swift files are added
// For static frameworks with CocoaPods, the module name uses underscores
#if __has_include("react_native_appsflyer-Swift.h")
#import "react_native_appsflyer-Swift.h"
#elif __has_include("react-native-appsflyer-Swift.h")
#import "react-native-appsflyer-Swift.h"
#elif __has_include(<react_native_appsflyer/react_native_appsflyer-Swift.h>)
#import <react_native_appsflyer/react_native_appsflyer-Swift.h>
#elif __has_include(<react-native-appsflyer/react-native-appsflyer-Swift.h>)
#import <react-native-appsflyer/react-native-appsflyer-Swift.h>
#else
#warning "Swift header not found. Make sure Swift files are compiled first."
#endif

// Force-link the class for static frameworks
__attribute__((constructor)) static void forceLinkRNAppsFlyerRPC() {
    [RNAppsFlyerRPC class];
}

@implementation RNAppsFlyerRPC

RCT_EXPORT_MODULE("RNAppsFlyerRPC")

// Create an instance of the Swift class
static RNAppsFlyerRPCImpl *swiftImpl = nil;

+ (void)initialize {
    if (self == [RNAppsFlyerRPC class]) {
        swiftImpl = [[RNAppsFlyerRPCImpl alloc] init];
    }
}

// RCTEventEmitter: Require main queue setup
+ (BOOL)requiresMainQueueSetup {
    return NO;
}

// Singleton pattern to ensure only one instance exists
+ (id)allocWithZone:(NSZone *)zone {
    static RNAppsFlyerRPC *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [super allocWithZone:zone];
    });
    return sharedInstance;
}

- (instancetype)init {
    if (self = [super init]) {
        if (swiftImpl) {
            [swiftImpl setEventEmitter:self];
        }
    }
    return self;
}

// TurboModule support - RCTEventEmitter should automatically work as TurboModule in New Architecture
// No manual implementation needed - React Native handles this automatically
#ifdef RCT_NEW_ARCH_ENABLED
// In Bridgeless mode, RCTEventEmitter modules are automatically registered as TurboModules
// The executeJson method will be exposed via the module registry
#endif // RCT_NEW_ARCH_ENABLED

#pragma mark - Exported Methods

// Execute JSON-RPC request
RCT_EXPORT_METHOD(executeJson:(NSString *)jsonRequest
                  resolve:(RCTPromiseResolveBlock)resolve
                  reject:(RCTPromiseRejectBlock)reject) {
    if (swiftImpl) {
        [swiftImpl executeJsonWithJsonRequest:jsonRequest
                                      resolve:resolve
                                       reject:reject];
    } else {
        reject(@"NOT_INITIALIZED", @"Swift implementation not available", nil);
    }
}

- (void)addListener:(NSString *)eventName {
    [super addListener:eventName];
}

- (void)removeListeners:(double)count {
    [super removeListeners:count];
}

- (NSArray<NSString *> *)supportedEvents {
    return @[@"onEvent"];
}

- (void)startObserving {
    // Events are pushed from native
}

- (void)stopObserving {
    // Events are pushed from native
}

@end

